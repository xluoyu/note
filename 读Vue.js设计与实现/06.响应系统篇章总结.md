## 响应式体系的建成

首先我们来建立一个基础的`Proxy` 以及 `effect`

```js
const obj = reactive({
  foo: 1,
  bar: 2
})

function reactive(target) {
  return new Proxy(target, {
    get (target, key) {
      return target[key]
    },
    set (target, key, newVal) {
      target[key] = newVal
    }
  })
}

function effect(fn) {
  fn()
}
```

创建一个`reactive`函数，它会将传入的对象包装成响应式对象，代理了`get`、`set`、`deleteProperty`等基础操作。
`effect`则是函数的执行入口，传入一个函数，默认情况下它会直接执行，并将当前执行函数挂载到`activeEffect`上，在当前函数的执行过程中会用到一些响应式数据，这是就会触发响应式数据的`get`操作，我们在其中加入`track`用来搜集依赖。

`track`





通过`new Proxy`的API可以实现对于对象`get`、`set`等基础操作的监听，并配合`effect`，在执行任务函数时对使用到的响应式数据进行依赖搜集。

`effect`主要做了一下这些事：

* 根据传入的函数和选项配置生成一个 `ReactiveEffect`。
* 在内部创建一个`Deps`数组，用来记录执行函数时所用到的响应式依赖。
* 根据传入的`scheduler`去执行传入的函数。

响应式API以`reactive`为例：

* 通过`createReactiveObject`来创建响应式数据，会传入`mutableHandlers`、`readonlyHandlers`等不同的控制器来应对不同需求的数据响应。
* `mutableHandlers`内部包含`new Proxy`的所需拦截器。
* `get`: 读取操作
  * 判断：如果当前`target`是数组，并且`key`是数组的`api`，
