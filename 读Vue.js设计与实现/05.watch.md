## watch的实现

`watch`的本质就是监测一个响应式数据，当数据发生变化时执行响应的回调函数。

```js

watch(obj, () => {
  console.log('数据发生变化了')
})

obj.foo++
```

我们可以通过`effect`以及`scheduler`来实现
```js
function watch(source, cb) {
  effect(
    () => source,
    {
      scheduler() {
        cb()
      }
    }
  )
}
```
这里在执行`() => source`时，就会读取`source`的值，来触发`track`收集。然而，如果传入的`source`是一个对象，那么我们需要读取对象内的每一个值，来使得对象上任意属性发生变化时都能触发回调函数。

```js
// 循环读取对象内的每一个属性
function traverse(value, seen = new Set()) {
  // 不考虑原始值、null、已读取过的情况
  if (typeof value !== 'object' || value === null || seen.has(value)) {
    return
  }

  seen.add(value)

  // 先考虑对象，使用for...in遍历对象的所有属性
  for (const k in value) {
    traverse(value[k], seen)
  }

  return value
}

export function watch(source, cb) {
  effect(
    () => traverse(source),
    {
      scheduler() {
        cb()
      }
    }
  )
}
```

除了`source`是个对象外，还要考虑其是个`getter`函数

```js
watch(() => obj.foo, () => {
  console.log('obj.foo 发生了改变')
})
```

```js
export function watch(source, cb) {
  /**
   * 我们判断一下source的情况进行封装
   */
  let getter

  if (typeof source === 'function') {
    getter = source
  } else {
    getter = () => traverse(source)
  }

  effect(
    () => getter(),
    {
      scheduler() {
        cb()
      }
    }
  )
}
```

之后我们还要在`cb`中返回新值与旧值。

```js
export function watch(source, cb) {
  let getter

  if (typeof source === 'function') {
    getter = source
  } else {
    getter = () => traverse(source)
  }
  let oldValue, newValue;

  const effectFn = effect( // 将副作用函数返回出来
    () => getter(),
    {
      lazy: true, // 这里我们要用上lazy属性
      scheduler() {
        newValue = effectFn() // 得到新值
        cb(newValue, oldValue)
        oldValue = newValue // 赋给旧值
      }
    }
  )

  oldValue = effectFn() // 第一次执行， 得到的值赋给旧值
}
```

## 立即执行的watch

在`Vue`中，我们通过给`watch`设置参数`{immediate: true}`，来立即执行。

```js
watch(() => obj.foo, () => {
  console.log('obj.foo 发生了改变')
}, {
  immediate: true
})
```

也就是说，当我们在执行`watch`函数时，直接执行调度器内的内容。

```js
function watch(source, cb, options = {}) {
  let getter

  if (typeof source === 'function') {
    getter = source
  } else {
    getter = () => traverse(source)
  }
  let oldValue, newValue;

  // 这里将调度器的内容重新封装，方便直接调用
  const job = () => {
    newValue = effectFn() // 得到新值
    cb(newValue, oldValue)
    oldValue = newValue // 赋给旧值
  }

  const effectFn = effect( // 将副作用函数返回出来
    () => getter(),
    {
      lazy: true, // 这里我们要用上lazy属性
      scheduler: job
      // scheduler() {
        // newValue = effectFn() // 得到新值
        // cb(newValue, oldValue)
        // oldValue = newValue // 赋给旧值
      // }
    }
  )

  if (options.immediate) {
    job()
  } else {
    oldValue = effectFn() // 第一次执行， 得到的值赋给旧值
  }
}

```

## flush

书中还介绍了`flush`属性
```js
watch(() => obj.foo, () => {
  console.log('obj.foo 发生了改变')
}, {
  flush: 'sync' // 还可以选的值为`'pre'`或`'post'`
})
```
`'sync'`表示同步执行，`'pre'`表示在组件更新前执行，`'post'`表示在组件更新后执行。

这里简单摸一下`post`的情况，因为`pre`设计到了组件更新的问题...

```js
const effectFn = effect( // 将副作用函数返回出来
    () => getter(),
    {
      lazy: true, // 这里我们要用上lazy属性
      scheduler: () => {
        // 在`flush`设置为`post`，我们将所执行的函数放至微任务中执行。
        if (options.flush === 'post') {
          const p = Promise.resolve()
          p.then(job)
        } else {
          job()
        }
      }
    }
  )
```