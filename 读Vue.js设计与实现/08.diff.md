## QA

### Q: diff的目的

A：当新旧 vnode 的子节点都是一组节点时，以最小的性能开销完成更新操作

## 简单的diff算法

我们为了最大限度的复用`Dom`，添加了属性`key`

当我们进行更新时，当遇到`oldChildren`与`newChildren`同为`Array`的情况下，我们会根据`patchFlag`是否标记`key`进行不同方式的更新。

> 在vue中，vFor指令下会对当前的`VNode.patchFlag` 添加`KEYED_FRAGMENT` 标记，以便做到上述的判断。

1. 当没有`key`时

我们取`oldChildren`与`newChildren`数量的最小值，然后遍历，依次做出更新

```js
for (let i = 0; i < minLength; i++) {
  patch(c1[i], c2[i], container)
}
```

之后针对新增、删除的节点，做出二次处理

```js
/**
 * 有新增的
 */
if (oldL < newL) {
  for (let i = minLength; i < newL; i++) {
    patch(null, c2[i], container)
  }
}

/**
 * 有删除的
 */
  if (oldL > newL) {
  for (let i = minLength; i < oldL; i++) {
    unmount(c1[i])
  }
}
```

2. 当有`key`时

我们通过两重`for`循环，依次找到`key`相同的两个节点，并记录旧节点的下标`lastIndex`，之后更新这两个节点

```js
patch(oldVnode, newVnode, container)
```

在遍历到下一个节点时，需要判断下标是否大于`lastIndex`，如果大于，则是正常现象，并再次记录，如果出现小于，则说明当前节点的位置发生了改变，我们就需要在更新后将当前的节点插入到上一个节点之后。

```js
const preVNode = c2[i - 1] // 1. 拿到上一个节点
if (preVNode) {
  const anchor = preVNode.el!.nextSibling as Node // 2. 上一个节点的真实节点，它的下一个节点

   /**
     * 插入到上一个节点与一个节点原下一个节点之间
     * newA、anchor
     * 
     * 插入
     * 
     * newA、newB、anchor
     * 
     * 放在anchor前面
     */
  insert(newVnode.el!, container, anchor)
}
```

解决了位置问题还要解决添加与删除的问题。

我们创建了一个`find`变量，它表示在本次遍历中是否找到相同的`key`。如果没有找到，则说明本次进入遍历的`newVNode`是一个新节点，我们需要添加进去
```js
patch(null, newVnode, container, anchor)
```

我们在两重循环结束后，需要根据`oldChildren`在进行依次遍历，比较旧列表中每一个节点的`key`都能找到新节点，如果找不到，那它就是被删除的节点。

```js
unmount(oldVNode)
```

## 双端比较

在`简单的diff`中我们通过双重循环来进行新旧节点列表的对比，是自上而下的比较方法，但它的性能并不是最优的，比如如下例子。

```js
const oldList = [
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
]

const newList = [
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2')
]
```

我们用之前的方式进行更新时，大致需要进行如下步骤

1. 找到`key === 3`的节点，确定下标
2. 找到`key === 1`的节点，移动节点
3. 找到`key === 2`的节点，移动节点

那么我们通过肉眼观察可以看到，其实只需要将`key === 3`的节点移动到头部即可，为此我们需要对首尾进行同时比较。

```js
let oldStartIdx = 0
let oldEndIdx = c1.length -1
let newStartIdx = 0
let newEndIdx = c2.length -1

/**
 * 四个索引的节点
 */
let oldStartVNode = c1[oldStartIdx]
let newStartVNode = c2[newStartIdx]
let oldEndVNode = c1[oldEndIdx]
let newEndVNode = c2[newEndIdx]
```

我们先将首尾下标以及对应的节点声明出来，当我们对某一对对应的节点做出处理后，就需要改动这些下标已经引用的节点

```js
/**
 * 开启循环
 * 
 * oldStartIdx <= oldEndIdx 说明旧列表还没处理完
 * newStartIdx <= newEndIdx 说明新列表还没处理完
 */
while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
  ...
}
```

1. 头部节点相同: `oldStartVNode.key === newStartVNode.key`

  我们先打上补丁，`patch(oldStartVNode, newStartVNode, container)`

  现在需要修改下标以及引用

  ```js
  oldStartVNode = c1[++oldStartIdx]
  newStartVNode = c2[++newStartIdx]
  ```

  由于两个都是头部节点，那么只需要修改对应的`startVNode`以及`startIdx`，都向后进一位

2. 尾部节点相同：`oldEndVNode.key === newEndVNode.key`

   同上，但是此时作出修改的是`endVNode`以及`endIdx`，向前进一位

3. 新头与旧尾相同：`oldEndVNode.key === newStartVNode.key`

   打上补丁...

   此时我们需要进行位置移动

   ```js
   insert(oldEndVNode.el!, container, oldStartVNode.el!)
   ```

   我们要将匹配到的旧尾的节点移动到头部，之后修改下标
   ```js
   oldEndVNode = c1[--oldEndIdx]
   newStartVNode = c2[++newStartIdx]
   ```

   旧尾向前进一，新头向后进一

4. 新尾与旧头相同：`oldStartVNode.key === newEndVNode.key`

    进行位置移动

   ```js
  insert(oldStartVNode.el!, container, oldEndVNode.el!.nextSibling)
   ```

   将旧头移动到末尾

   ```js
   oldStartVNode = c1[++oldStartIdx]
   newEndVNode = c2[--newEndIdx]
   ```

5. 以上四种情况外

   此时我们遇到了尴尬的情况，例子如下

```js
const oldList = [
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
]

const newList = [
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2')
]
```

  四种情况都对不上，那我们要怎么办呢？

  我们只看新头，也就是`key === 3`的节点，对旧节点做出查找

  ```js
    const idxInold = c1.findIndex(vnode => vnode && vnode.key === newStartVNode.key)
  ```

  从旧节点中找到对应节点的下标。

  