## QA

### Q: diff的目的

A：当新旧 vnode 的子节点都是一组节点时，以最小的性能开销完成更新操作

## 简单的diff算法

我们为了最大限度的复用`Dom`，添加了属性`key`

当我们进行更新时，当遇到`oldChildren`与`newChildren`同为`Array`的情况下，我们会根据`patchFlag`是否标记`key`进行不同方式的更新。

> 在vue中，vFor指令下会对当前的`VNode.patchFlag` 添加`KEYED_FRAGMENT` 标记，以便做到上述的判断。

1. 当没有`key`时

我们取`oldChildren`与`newChildren`数量的最小值，然后遍历，依次做出更新

```js
for (let i = 0; i < minLength; i++) {
  patch(c1[i], c2[i], container)
}
```

之后针对新增、删除的节点，做出二次处理

```js
/**
 * 有新增的
 */
if (oldL < newL) {
  for (let i = minLength; i < newL; i++) {
    patch(null, c2[i], container)
  }
}

/**
 * 有删除的
 */
  if (oldL > newL) {
  for (let i = minLength; i < oldL; i++) {
    unmount(c1[i])
  }
}
```

2. 当有`key`时

我们通过两重`for`循环，依次找到`key`相同的两个节点，并记录旧节点的下标`lastIndex`，之后更新这两个节点

```js
patch(oldVnode, newVnode, container)
```

在遍历到下一个节点时，需要判断下标是否大于`lastIndex`，如果大于，则是正常现象，并再次记录，如果出现小于，则说明当前节点的位置发生了改变，我们就需要在更新后将当前的节点插入到上一个节点之后。

```js
const preVNode = c2[i - 1] // 1. 拿到上一个节点
if (preVNode) {
  const anchor = preVNode.el!.nextSibling as Node // 2. 上一个节点的真实节点，它的下一个节点

   /**
     * 插入到上一个节点与一个节点原下一个节点之间
     * newA、anchor
     * 
     * 插入
     * 
     * newA、newB、anchor
     * 
     * 放在anchor前面
     */
  insert(newVnode.el!, container, anchor)
}
```

解决了位置问题还要解决添加与删除的问题。

我们创建了一个`find`变量，它表示在本次遍历中是否找到相同的`key`。如果没有找到，则说明本次进入遍历的`newVNode`是一个新节点，我们需要添加进去
```js
patch(null, newVnode, container, anchor)
```

我们在两重循环结束后，需要根据`oldChildren`在进行依次遍历，比较旧列表中每一个节点的`key`都能找到新节点，如果找不到，那它就是被删除的节点。

```js
unmount(oldVNode)
```

## 双端比较

在`简单的diff`中我们通过双重循环来进行新旧节点列表的对比，是自上而下的比较方法，但它的性能并不是最优的，比如如下例子。

```js
const oldList = [
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
]

const newList = [
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2')
]
```

我们用之前的方式进行更新时，大致需要进行如下步骤

1. 找到`key === 3`的节点，确定下标
2. 找到`key === 1`的节点，移动节点
3. 找到`key === 2`的节点，移动节点

那么我们通过肉眼观察可以看到，其实只需要将`key === 3`的节点移动到头部即可，为此我们需要对首尾进行同时比较。

```js
let oldStartIdx = 0
let oldEndIdx = c1.length -1
let newStartIdx = 0
let newEndIdx = c2.length -1

/**
 * 四个索引的节点
 */
let oldStartVNode = c1[oldStartIdx]
let newStartVNode = c2[newStartIdx]
let oldEndVNode = c1[oldEndIdx]
let newEndVNode = c2[newEndIdx]
```

我们先将首尾下标以及对应的节点声明出来，当我们对某一对对应的节点做出处理后，就需要改动这些下标已经引用的节点

```js
/**
 * 开启循环
 * 
 * oldStartIdx <= oldEndIdx 说明旧列表还没处理完
 * newStartIdx <= newEndIdx 说明新列表还没处理完
 */
while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
  ...
}
```

1. 头部节点相同: `oldStartVNode.key === newStartVNode.key`

  我们先打上补丁，`patch(oldStartVNode, newStartVNode, container)`

  现在需要修改下标以及引用

  ```js
  oldStartVNode = c1[++oldStartIdx]
  newStartVNode = c2[++newStartIdx]
  ```

  由于两个都是头部节点，那么只需要修改对应的`startVNode`以及`startIdx`，都向后进一位

2. 尾部节点相同：`oldEndVNode.key === newEndVNode.key`

   同上，但是此时作出修改的是`endVNode`以及`endIdx`，向前进一位

3. 新头与旧尾相同：`oldEndVNode.key === newStartVNode.key`

   打上补丁...

   此时我们需要进行位置移动

   ```js
   insert(oldEndVNode.el!, container, oldStartVNode.el!)
   ```

   我们要将匹配到的旧尾的节点移动到头部，之后修改下标
   ```js
   oldEndVNode = c1[--oldEndIdx]
   newStartVNode = c2[++newStartIdx]
   ```

   旧尾向前进一，新头向后进一

4. 新尾与旧头相同：`oldStartVNode.key === newEndVNode.key`

    进行位置移动

   ```js
  insert(oldStartVNode.el!, container, oldEndVNode.el!.nextSibling)
   ```

   将旧头移动到末尾

   ```js
   oldStartVNode = c1[++oldStartIdx]
   newEndVNode = c2[--newEndIdx]
   ```

5. 以上四种情况外

   此时我们遇到了尴尬的情况，例子如下

```js
const oldList = [
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
]

const newList = [
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2')
]
```

  四种情况都对不上，那我们要怎么办呢？

  我们只看新头，也就是`key === 3`的节点，对旧节点做出查找

  ```js
    const idxInold = c1.findIndex(vnode => vnode && vnode.key === newStartVNode.key)
  ```

  从旧节点中找到对应节点的下标，之后就是打补丁并移动位置

  ```js
   if (idxInold > 0) {
      // 找到了
      const vnodeToMove = c1[idxInold]

      // 打个补丁
      patch(vnodeToMove, newStartVNode, container)

      // 将这个节点放到真实节点最前方
      insert(vnodeToMove.el!, container, oldStartVNode.el)

      // 已经处理过这个节点，所以从c1中去除
      ;(c1[idxInold] as VNode | undefined) = undefined
    } else {
      // 没找到，那么这个节点就是新加的
      // 挂载并放在旧节点列表的头部
      patch(null, newStartVNode, container, oldStartVNode.el)
    }

    newStartVNode = c2[++newStartIdx]
  ```

  本阶段只处理了新列表中的头部节点，所以只移动`newStartIdx`即可。注意：我们在本阶段处理节点时，将对应的旧列表中的节点改成了`undefined`，这就会导致在某个阶段所取到的旧列表中的节点会是`undefined`，所以我们还需要加两层判断

  ```js
  if (!oldStartVNode) {
    console.log('oldStartVNode 为空')
    // 说明该节点被处理过了
    oldStartVNode = c1[++oldStartIdx]
  } else if (!oldEndVNode) {
    console.log('oldEndVNode 为空')

    oldEndVNode = c1[--oldEndIdx]
  }
  ```

  在遇到`undefined`的情况，直接修改对应的下标。

现在`while`循环结束，正常情况下，`oldEndIdx < oldStartIdx` 表示旧列表处理完成，`newEndIdx < newStartIdx` 新列表处理完成。 但我们还需要考虑到有新增节点和卸载节点的情况。

1. `oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx` 新列表还有未处理的节点

```js
if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
  for (let i = newStartIdx; i <= newEndIdx; i++) {
    patch(null, c2[i], container, oldStartVNode.el)
  }
}
```

我们从此时的`newStartIdx`下标出发，将剩余的节点打上补丁并插入到此时的`oldStartVNode`之前，因为在`while`结束之后，`oldStartVNode`已经到了对应的位置

2. `newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx` 旧列表还有未处理的节点

```js
for (let i = oldStartIdx; i <= oldEndIdx; i++) { 
  console.log('去卸载了', i, c1[i])
  unmount(c1[i])
}
```

不需要多说，直接循环卸载掉即可。

## 快速diff

快速diff是`vue3`中引用的算法，比`vue2`中的双端算法更优。

我们要分几个步骤：
  1. 预处理
  2. 对剩余节点的判断处理
  3. 过滤出需要移动的节点组
  4. 移动节点

### 预处理

首先，我们需要对diff的两者进行预处理。举个例子: 

```js
const old = [
  h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
  h('p', {key: 6}, '哈哈哈6'),
  h('p', {key: 5}, '哈哈哈5')
]

const new = [
  h('p', {key: 1}, 'n哈哈哈1'),
  h('p', {key: 3}, 'n哈哈哈3'),
  h('p', {key: 4}, 'n哈哈哈4'),
  h('p', {key: 2}, 'n哈哈哈2'),
  h('p', {key: 7}, 'n哈哈哈7'),
  h('p', {key: 5}, 'n哈哈哈5'),
]
```

可以看到在本例子中，两者的头部节点与尾部节点都是相同的，所以我们可以先`patch`前后相同的节点。

```js
let j = 0

let oldVNode = c1[j]
let newVNode = c2[j]

/**
 * 对比前置节点
 * 
 * 直到找到带有不同key的节点
 */
while (oldVNode.key === newVNode.key) {
  console.log('处理前置节点', oldVNode, newVNode)
  patch(oldVNode, newVNode, container)

  j++

  oldVNode = c1[j]
  newVNode = c2[j]
}
```

我们从头部开始，依次对比两方的`key`，当`key`相同时直接更新，然后继续向后对比。

同理，处理尾部节点。

```js
let oldEndIdx = c1.length - 1
let newEndIdx = c2.length - 1

let oldEndVNode = c1[oldEndIdx]
let newEndVNode = c2[newEndIdx]

/**
 * 对比后置节点
 * 
 */
while (oldEndVNode.key === newEndVNode.key) {
  console.log('处理后置节点', oldEndVNode, newEndVNode)

  patch(oldEndVNode, newEndVNode, container)

  oldEndVNode = c1[--oldEndIdx]
  newEndVNode = c2[--newEndIdx]
}
```

### 对剩余节点的判断处理

现在我们处理了前后比较容易处理的节点，当前还剩如下节点。

```js
const old = [
  // h('p', {key: 1}, '哈哈哈1'),
  h('p', {key: 2}, '哈哈哈2'),
  h('p', {key: 3}, '哈哈哈3'),
  h('p', {key: 4}, '哈哈哈4'),
  h('p', {key: 6}, '哈哈哈6'),
  // h('p', {key: 5}, '哈哈哈5')
]

const new = [
  // h('p', {key: 1}, 'n哈哈哈1'),
  h('p', {key: 3}, 'n哈哈哈3'),
  h('p', {key: 4}, 'n哈哈哈4'),
  h('p', {key: 2}, 'n哈哈哈2'),
  h('p', {key: 7}, 'n哈哈哈7'),
  // h('p', {key: 5}, 'n哈哈哈5'),
]
```

那么我们需要分几种情况讨论

1. 当旧节点已经处理完成(`j > oldEndIdx`) 但是新节点还有剩余(`j <= newEndIdx`)

  此时就说明，在新节点中剩下的都是新增的节点，所以我们直接挂载

```js
  const anchorIdx = newEndIdx + 1

  const anchor = anchorIdx < c2.length ? c2[anchorIdx].el : null

  while (j <= newEndIdx) {
    console.log('处理新增节点', c2[j])
    patch(null, c2[j++], container, anchor)
  }
```