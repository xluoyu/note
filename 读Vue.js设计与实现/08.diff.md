## QA

### Q: diff的目的

A：当新旧 vnode 的子节点都是一组节点时，以最小的性能开销完成更新操作

## 简答的diff算法

我们为了最大限度的复用`Dom`，添加了属性`key`

当我们进行更新时，当遇到`oldChildren`与`newChildren`同为`Array`的情况下，我们会根据`patchFlag`是否标记`key`进行不同方式的更新。

> 在vue中，vFor指令下会对当前的`VNode.patchFlag` 添加`KEYED_FRAGMENT` 标记，以便做到上述的判断。

1. 当没有`key`时

我们取`oldChildren`与`newChildren`数量的最小值，然后遍历，依次做出更新

```js
for (let i = 0; i < minLength; i++) {
  patch(c1[i], c2[i], container)
}
```

之后针对新增、删除的节点，做出二次处理

```js
/**
 * 有新增的
 */
if (oldL < newL) {
  for (let i = minLength; i < newL; i++) {
    patch(null, c2[i], container)
  }
}

/**
 * 有删除的
 */
  if (oldL > newL) {
  for (let i = minLength; i < oldL; i++) {
    unmount(c1[i])
  }
}
```

2. 当有`key`时

我们通过两重`for`循环，依次找到`key`相同的两个节点，并记录旧节点的下标`lastIndex`，之后更新这两个节点

```js
patch(oldVnode, newVnode, container)
```

在遍历到下一个节点时，需要判断下标是否大于`lastIndex`，如果大于，则是正常现象，并再次记录，如果出现小于，则说明当前节点的位置发生了改变，我们就需要在更新后将当前的节点插入到上一个节点之后。

```js
const preVNode = c2[i - 1] // 1. 拿到上一个节点
if (preVNode) {
  const anchor = preVNode.el!.nextSibling as Node // 2. 上一个节点的真实节点，它的下一个节点

   /**
     * 插入到上一个节点与一个节点原下一个节点之间
     * newA、anchor
     * 
     * 插入
     * 
     * newA、newB、anchor
     * 
     * 放在anchor前面
     */
  insert(newVnode.el!, container, anchor)
}
```

解决了位置问题还要解决添加与删除的问题。

我们创建了一个`find`变量，它表示在本次遍历中是否找到相同的`key`。如果没有找到，则说明本次进入遍历的`newVNode`是一个新节点，我们需要添加进去
```js
patch(null, newVnode, container, anchor)
```

我们在两重循环结束后，需要根据`oldChildren`在进行依次遍历，比较旧列表中每一个节点的`key`都能找到新节点，如果找不到，那它就是被删除的节点。

```js
unmount(oldVNode)
```