## Cookie Storage
cookie 设计时并不是用来做本地存储的，它是为了弥补http在状态上的不足。
> http是无状态的，他不会记住用户的操作，在需要记住用户状态的场景有限制

* cookie 体积小(4kb)，只能存储少量信息。
* 向同一个域名下发送请求，都会携带相同的 Cookie。
一般用于在请求时携带cookie，通过服务端解析，获取用户的状态。

storage则是用来做本地存储的。

local storage 针对同一个域名，同一个域名下，会存储相同的一段 Local Storage。

* 体积上限有5M
* 不与服务端通讯
* 只有setItem、getItem两个结口

session storage 基本和local一致

* 会话级别的存储。关闭tag页就会删除

## 跨域
跨域的主要原因就是 浏览器的同源策略。指协议、域名、端口一致的情况下，才属于同源

多级域名和主域名一致，属于同源 如
```
https://www.baidu.com
https://test.baidu.com
```
跨域时会导致：
 * 不能发送请求
 * 无法获取DOM
 * 无法读取 storage 、 cookie

跨域是对浏览器的限制

## 跨域解决方案
1. JSONP
由于 `<script>`标签没有跨域的限制，通过创建`<script src='***'>`从其他源获取数据

缺点：
* 仅支持get请求
* 不安全

2. CORS
CORS（跨域资源共享）是一种机制，它允许浏览器向跨源服务器发出请求， 并且整个 CORS 通信过程都是浏览器自动完成的。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS

3. postMessage
HTML5 的 API
它主要用于解决
* 页面和其他新打开窗口间的数据传递
* 页面与iframe消息传递
* 多窗口间的消息传递

4. websocket
HTML5的持久化协议，长连接。
成功建立后可实现 client 主从发出数据

5. 请求代理
使用 Node 中间件

同源策略只从在于浏览器，通过访问node中间层，代理到其他服务器即可实现跨域

Nginx反向代理

修改Nginx配置即可

## 浏览器渲染过程
1. 解析HTML，生成DOM树
2. 解析CSS， 生成CSS树
3. 两者结合， 生成渲染树
4. 从根节点，计算每个元素大小、位置，给出准确坐标，得到布局渲染树
5. 便利渲染树，将每个节点用UI引擎绘制。将整棵树绘制到页面上

## 回流 重绘
回流，又叫重排。当元素的尺寸，结构发生改变，影响布局，浏览器会重新渲染页面

触发操作：
* 添加删除DOM元素
* 改变边框、边距、宽高等
* 改变窗口(resize)
...

重绘。当元素的样式发生改变，不影响布局，浏览器只需要对元素进行更新。
触发操作：
* 改变颜色
* 背景图
...

回流必发生重绘！

使用transition 修改 top left 等不会触发回流

